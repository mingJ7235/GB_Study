스프링 MVC 프로젝트의 기본 구성
	스프링 MVC에서 어떤 단계를 거쳐서 실행되는 지를 이해해야 문제 발생 시 
	빠른 대처와 대안을 찾을 수 있다. 

	웹 프로젝트는 3-tier(티어) 방식으로 구성한다.
	각각의 티어는 인터페이스를 잉요해서 설계한다.

	Presentation ↔ Business ↔ Persistence

[Presentation Tier (화면 계층)]  -> .jsp
	보여지는 부분 (jsp부분)
	화면에 보여주는 기술을 사용하는 영역이다. 
	Servlet/JSP 혹은 스프링 MVC가 담당하는 영역이며 화면 구성이 이에 속한다. 

[Business Tier(비지니스 계층)]  -> .java
	순수한 비지니스 로직을 담고 있는 영역.
	고객이 원하는 요구사항을 반영하는 계층이기 때문에 중요한 영역이다. 
	이 영역의 설계는 고객의 요구사항과 정확히 일치해야 하며, '000Service'와 같은 이름으로
	구성한다.  (ex> 000Service.java)

[Persistence Tier(영속 계층 혹은 데이터 계층)]
	데이터를 어떤 방식으로 보관하고, 사용하는 가에 대한 설계가 들어가는 계층.
	일반적으로 DB를 많이 이용하지만, 상황에 따라서 네트워크 호출 혹은 원격 호출 등의 
	기술이 접목된다. 

	**계층 관계도
	[Spring MVC] ↔ [Spring Core] 
			   ↕
		        [spring-mybatis] ↔ [MyBatis] ↔ [DB]
			(네임스페이스)

	각 영역은 독립적으로 설계되어 나중에 특정한 기술이 변하더라도 필요한 부분을
	전자제품의 부품처럼 쉽게 교환할 수 있게 하자는 방식이다.
	각 연결 부위는 인터페이스를 이용해서 설계하는 것이 일반적이 구성 방식이다. 
------------------------------------------------------------------------------------------------------------------------

Naming Convention(명명규칙)  (패키지 이름 붙이는법)

- com.koreait.
		config		: 프로젝트와 관련된 설정 클래스 들의 보관 패키지
		controller	: 스프링 MVC의 Controller들의 보관 패키지
		service		: 스프링 Service 인터페이스와 구현 클래스 패키지
		domain		: VO, DTO 클래스들의 패키지
		persistence	: MyBatis Mapper 인터페이스 패키지
		exception	: 웹 관련 예외처리 패키지
		aop		: 스프링의 AOP 관련 패키지
		security		: 스프링 Security 관련 패키지
		tuil		: 각종 유틸리티 클래스 관련 패키지
------------------------------------------------------------------------------------------------------------------------
ex02프로젝트 생성
	1. 빌드패스에 ojdbc6.jar추가, Assembly에도 추가.
	2. pom.xml 복붙
	3. root0context.mxl복붙, namespaces에서 context, spring-bybatis체크
	4. main/resources에 있는 log4jdbc.. 파일 복사 후 ex02 같은 경로에 붙여넣기
	5. test/resources에 있는 log4j.xml 내용 복사 후 ex02같은 경로의 파일에 내용 붙여 넣기
	6.Tomcat mocules에서 path를 "/board"로 변경

------------------------------------------------------------------------------------------------------------------------
비지니스 계층
	프레젠테이션 계층과 영속(Persistence) 계층의 중간다리 역할을 한다.
	영속 계층은 DB를 기준으로, 
	비지니스 계층은 로직을 기준으로 처리한다. 

	예를 들어 쇼핑몰에서 상품 구매 시 포인트 적립을 한다고 가정한다면,
	영속 계층의 설계는 '상품', '회원'으로 나누어 설계하지만,
	비지니스 계층은 상품 영역과 회원 영역을 동시에 사용해서 하나의 로직을 처리하게 된다.

	하나의 트랜젝션을위해서 많은 SQL을 사용할 수 있다. 
	하나의 메소드를 또 만들어서 거기에 쿼리문을 모아두고, 비지니스 계층의 설계에서는
	그 메소드 하나를 사용하는것이다. (각각의 쿼리가 담긴 컨트롤러를 불러오는것이아니다.)
	그렇기때문에 비지니스 계층은 서비스 이름으로 만드는것이다. '000Service.java'

	Business Tier	←	Service	←	Persistence Tier
예>	                                  구매서비스		상품 처리 객체 (select문)
						회원 처리 객체 (update문)

	*일반적으로 비지니스 영역에 있는 객체들은 서비스(Service)라는 용어를 많이 사용한다. 

------------------------------------------------------------------------------------------------------------------------
복습순서!>>
매퍼 -> 쿼리문(xml 파일) -> 메소드 사용하는곳(service) -> 서비스 구현(imple) -> 생성자를 초기화 하니까 setter없이 allargsconstructor를 사용함


의존성 주입 (재설명)
1. 순서
	- 준비 @Component, @Service, @Controller, @Repository등을 사용,
		root-context.xml에 등록된 Bean이 Context에 할당
	- 주입 @AutoWired로 요청 -> root-context.xml -> 주입
		*@Qualifier를 사용하면 동일한 타입 중 골라서 주입할 수 있음.
		*A : id를 설정했다면 id 값 작성, 어노테이션으로 설정했다면 해당 클래스의
		앞글자만 소문자로 변경된 id값 작성
		예) <bean id = "a" ....> @Qaulifier("a")
		    @Repository 
		     class A_Repository	-> @Qualifier("a_Repository")

2. 목적
	필드를 사용하는 로직에서 다양한 선택을 할 수 있도록 설계하기 위함.
	선언부와 사용부의 주소를 같이 공유해야 하며, 개발의 유연성을 유지하기 위함.
	스프링은 주입으로 new를 한다고 생각하면 된다!
	사용하는 쪽에서 할당하도록 하는것이다.

------------------------------------------------------------------------------------------------------------------------















			