<Day02>

1) this

클래스를 선언하면 this라는 변수가 자동적으로 생긴다.

- 하나의 클래스로부터 여러 객체가 생성된다.
- 각 객체별로 같은 필드를 구성하고 있고, 특정 객체의 멤버변수에
접근하기 위해서는 해당 객체가 가지고 있는 주소값이 필요하다.
- 소스코드상에서 필드안에 메소드를 선언할 때 한 번만 선언하고,
그 안에서 멤버변수를 사용할 때 어떤 객체의 멤버변수인지를 알 수가 없다. 
- 따라서 객체가 메소드에 접근하면 가지고 있는 주소값을 해당 메소드에게
전달해 주어야 하고, 전달된 주소값을 this라는 변수가 받는다. 
따라서 this.멤버변수로 사용해야 정확히 원하는 필드에 접근할 수 있게 된다. 
- 하지만 매번 this.을 붙이기 번거롭기 때문에 지역변수와 이름이 같지 않다면
생략이 가능하다. 

*참조 : 자바는 단일 프로세스다. this는 단 하나일 수밖에 없다. 
------------------------------------------
다형성 (polymorphism) - 메소드의 성질
	1. 오버로딩(Overloading)
		매개변수의 개수 혹은 타입이 서로 다르면,
		같은 이름의 메소드로 선언이 가능하다. 
	2. 



-----------------------------------------------
상속 (inheritance)
	1. 기존에 선언된 클래스의 필드를 새롭게 선언하는 클래스의 필드에서
	   사용하고 싶을 때 ->API
	2. 여러 클래스를 선언할 때 공통 필드가 많다면, 부모 클래스를 선언하고
	   공통 필드 선언 후 여러 클래스들에게 상속해주기 위해서 -> 사용자클래스

상속 문법
	class A {
		A필드
	}

	class B extends A{
		A, B필드
	}


A : 부모클래스, 상위클래스, 슈퍼클래스, 기반클래스
B : 자식클래스, 하위클래스, 서브클래스, 파생클래스


상속의 작동 원리
	자식 객체로 부모 필드에 접근하기 위해서는 당연히 부모 필드가 메모리에
	할당 되어야 한다. 하지만 자식 객체를 객체화 할 때, 자식 생성자만 호출한다.
	자식 생성자만 호출하게 되면 자식 객체는 자식 필드만 접근이 가능하게 되므로
	자식 생성자 호출 시 자동으로 부모 생성자를 먼저 호출하게 된다. 
	따라서 부모 필드가 먼저 메모리에 할당 된 후 자식 필드가 할당 되기 때문에
	자식 객체로 부모 필드에 접근할 수 있게 된다. 
	자식 필드 내에서 부모 필드에 접근할 때에는 super 키워드를 사용하고,
	부모 생성자는 super()로 작성한다. 


다형성 (polymorphism) - 메소드의 성질
	1.
	2. 오버라이딩 (재정의, Overriding)
	- 무시하다 라는 의미. 즉, 부모를 무시하고 내가 만들겠다! 라는의미
	String data ="안녕";
	data = "하세요";
	syso(data);
	-> 하세요만 출력된다. 즉 이런 오버라이딩은 이런 의미다. 
	덮어 쓰여지는 것 !!!! 

	-부모에 있는 메소드가 자식에서 수정이 필요하다면,
	똑같은 이름으로 자식에게 선언해준다. 
	부모 필드에 선언된 메소드가 메모리에 먼저 할당되고,
	그 다음 자식 필드에서 재정의된 메소드가 할당된다. 
	같은 이름의 저장공간은 선언될 수 없으므로,
	이미 선언된 부모의 메소드 저장공간에 자식에서 새롭게
	재정의한 코드의 주소값이 들어간다. 
	
	원리 예) 
	int data =10; //부모
	data = 20; //자식
	syso (data); //자식객체로 접근한 메소드
	-> 결과는 자식값. 

	자식에서 재정의된 소스코드르 바뀌기 전에 부모의 메소드를 호출하면
	효율적으로 재정의를 구현할 수 있게 된다. 
	원리 예)
	String data = "안녕"; //부모
	data += "하세요" //자식에서 부모의 기능을 그대로 유지한 후 추가


--------------------------------------------
클래스 배열
	같은 타입의 객체가 여러개 있을 때
	객체명도 여러 개이다. 이름이 여러 개이면 관리하기 어렵기 때문에
	객체 배열로 선언하여 사용한다. 

클래스 배열 선언
	1.클래스명 [] 배열명 = new 클래스명[길이];
	2.클래스명 [] 배열명 {
		new 클래스명,
		new 클래스명,
		new 클래스명,
		...
	}

클래스 배열 사용
	배열명[i].필드명
	배열명[i].메소드명()


----------------------------------------
Casting (강제 형변환)
타입이 다를때 서로 하나로 모으는 기법... ! 
	
	모든 자식은 부모 타입이다. 
	up casting
		부모 타입에 자식 값을 넣는 형변환 (부모타입으로 변환)

	down casting
		up casting된 객체를 자식 타입으로 형변환 (자식타입으로 변환)

그렇다면 왜 쓰냐?
	하나의 부모에서 자식은 여러개이다. 
	모든 자식을 하나로 묶기 위해서는 up casting이 필요하다. 
	up casting한 객체를 사용하기 위해서 쓰는것이아니라,
	묶어서 받아서 타입 비교후에 다시 down casting을 해주는 것이다.
	즉, 전달받은 자식 값의 필드를 다시 모두 사용하기 위해서는
	down casting으로 복원한다. 

타입 비교 (instanceof)
	a instanceof A : a객체가 A타입이면 true, 아니면 false

	예)
	"안녕" instanceof String : true



----------------------------------
2월(JAVA, JDBC)
	
3월(HTML, CSS, 크롤링(셀레니움), Javascript(jQuery, DOM, BOM) )

4월(JSP, MVC, Ajax, JSON, 팀 프로젝트(SVN), 출시(리눅스, 네이버 클라우드 플랫폼) )

5월(Spring framework, DI, AOP, IoC, POJO, Tier, Spring MVC,Maven, 썸네일(극악난이도),...)

6월(팀 프로젝트 or 개인프로젝트 - 이관 (jsp를 spring으로 이관), Git, JPA or 면접준비)


스타트업

중소기업

중견기업

대기업



1. 회사에 직적 가서 보는 코딩테스트
	실생활 예제 알고리즘 공부 
	문제 해결 능력

정보처리 기사 자격증 (있으면 좋음)


	
1. Node.js, react, vue, 앵귤러.js
Framework : 작업하기 위한 틀 

Spring framework(java, xml, html,....알아야할 언어가 많다) : 멀티 쓰레드, 복잡한 cpu연산이 있는 페이지에서 최고임.
						결제, 배송 등등 복잡한 페이지도 매우 빠르게 처리 가능
	-> 제일어렵다. 하지만 강력하다.
	-> 안정성이 뛰어나다. 대기업, 공공기관, 정부(전자정부 표준 프레임워크 egov) 

Node : 싱글 쓰레드 (느리다. 싱글이니까. 복잡한 페이지에선 느림)
	-> 입출력에 특화가 되어있다. SNS, 영상출력 등에서 최고임. 
	-> JS만 알면 매우 강력하게 사용할 수 있다. 
	-> 스타트업, 중소기업에서 선호

2. 파견업체, 자체 솔루션 업체 (규모)

파견 
	- 장점 : 단기간 다양한 프로젝트 경험으로 스펙이 좋아짐, 다양한 기술 습득, 트랜드 습득 가능
	- 단점 : 출근길이 변경된다. (안정성이떨어짐)

유지보수 (경력직)
	- 장점 : 안정적이다, 기술을 깊게 배울 수 있다. 
	- 단점 : 우물 안 개구리가 될 수 있다. 개인 자기개발이 필요하다. 

3. 루트 (경로)

	1) 취업준비 (최소1년) > 대기업 신입
	2) 취업준비 (6개월) > 중소기업 > 대기업 경력직
	3) 취업준비 (7개월) > 대기업 인턴 > 대기업 정규직
	4) 취업준비 (5개월) > 스타트업 신입사원 > 중소기업 경력직 > 대기업 경력직 (추천)

	5) 취업준비 (?) > 중소기업 신입사원 (최소 1년 재직 ) > 창업
	6) 취업준비 (?) > 대기업 신입사원 (최소 1년 재직 ) > 창업
	
	개발자 평균 연봉 : 2400 ~ 3000



------------------------------------------------------











