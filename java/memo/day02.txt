<Day02>

1) this

클래스를 선언하면 this라는 변수가 자동적으로 생긴다.

- 하나의 클래스로부터 여러 객체가 생성된다.
- 각 객체별로 같은 필드를 구성하고 있고, 특정 객체의 멤버변수에
접근하기 위해서는 해당 객체가 가지고 있는 주소값이 필요하다.
- 소스코드상에서 필드안에 메소드를 선언할 때 한 번만 선언하고,
그 안에서 멤버변수를 사용할 때 어떤 객체의 멤버변수인지를 알 수가 없다. 
- 따라서 객체가 메소드에 접근하면 가지고 있는 주소값을 해당 메소드에게
전달해 주어야 하고, 전달된 주소값을 this라는 변수가 받는다. 
따라서 this.멤버변수로 사용해야 정확히 원하는 필드에 접근할 수 있게 된다. 
- 하지만 매번 this.을 붙이기 번거롭기 때문에 지역변수와 이름이 같지 않다면
생략이 가능하다. 

*참조 : 자바는 단일 프로세스다. this는 단 하나일 수밖에 없다. 
------------------------------------------
다형성 (polymorphism) - 메소드의 성질
	1. 오버로딩(Overloading)
		매개변수의 개수 혹은 타입이 서로 다르면,
		같은 이름의 메소드로 선언이 가능하다. 
	2. 



-----------------------------------------------
상속 (inheritance)
	1. 기존에 선언된 클래스의 필드를 새롭게 선언하는 클래스의 필드에서
	   사용하고 싶을 때 ->API
	2. 여러 클래스를 선언할 때 공통 필드가 많다면, 부모 클래스를 선언하고
	   공통 필드 선언 후 여러 클래스들에게 상속해주기 위해서 -> 사용자클래스

상속 문법
	class A {
		A필드
	}

	class B extends A{
		A, B필드
	}


A : 부모클래스, 상위클래스, 슈퍼클래스, 기반클래스
B : 자식클래스, 하위클래스, 서브클래스, 파생클래스


상속의 작동 원리
	자식 객체로 부모 필드에 접근하기 위해서는 당연히 부모 필드가 메모리에
	할당 되어야 한다. 하지만 자식 객체를 객체화 할 때, 자식 생성자만 호출한다.
	자식 생성자만 호출하게 되면 자식 객체는 자식 필드만 접근이 가능하게 되므로
	자식 생성자 호출 시 자동으로 부모 생성자를 먼저 호출하게 된다. 
	따라서 부모 필드가 먼저 메모리에 할당 된 후 자식 필드가 할당 되기 때문에
	자식 객체로 부모 필드에 접근할 수 있게 된다. 
	자식 필드 내에서 부모 필드에 접근할 때에는 super 키워드를 사용하고,
	부모 생성자는 super()로 작성한다. 


다형성 (polymorphism) - 메소드의 성질
	1.
	2. 오버라이딩 (재정의, Overriding)
	- 무시하다 라는 의미. 즉, 부모를 무시하고 내가 만들겠다! 라는의미
	String data ="안녕";
	data = "하세요";
	syso(data);
	-> 하세요만 출력된다. 즉 이런 오버라이딩은 이런 의미다. 
	덮어 쓰여지는 것 !!!! 

	-부모에 있는 메소드가 자식에서 수정이 필요하다면,
	똑같은 이름으로 자식에게 선언해준다. 
	부모 필드에 선언된 메소드가 메모리에 먼저 할당되고,
	그 다음 자식 필드에서 재정의된 메소드가 할당된다. 
	같은 이름의 저장공간은 선언될 수 없으므로,
	이미 선언된 부모의 메소드 저장공간에 자식에서 새롭게
	재정의한 코드의 주소값이 들어간다. 
	
	원리 예) 
	int data =10; //부모
	data = 20; //자식
	syso (data); //자식객체로 접근한 메소드
	-> 결과는 자식값. 

	자식에서 재정의된 소스코드르 바뀌기 전에 부모의 메소드를 호출하면
	효율적으로 재정의를 구현할 수 있게 된다. 
	원리 예)
	String data = "안녕"; //부모
	data += "하세요" //자식에서 부모의 기능을 그대로 유지한 후 추가











