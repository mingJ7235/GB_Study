내부 클래스 : 클래스내에 클래스
	안드로이드에서 많이 사용됨
	클래스 내부에 필드로써 클래스가 존재하는 것
	

	익명 내부 클래스..!

----------------------------------------
[실습]
인터페이스 : Cafe (아직 구현되지 않은 3가지 기능)
Starbucks (본사)
Road (main)
스타벅스 매장은 한 개가 아니라 여러개이다.
각 매장은 신규 오픈 시 본사에 정보를 등록해야 한다.
등록해야할 정보는 아래와 같다.
1. 메뉴
2. 가격
3. 판매방식

본사에서는 신규 오픈 한 매장에서 전달한 3가지 정보를
직접 사용하는 등록 메소드를 구현해 놓는다. 
신규 오픈한 매장은 등록메소드 실행 시 3가지 정보를 구현하게 되고
콘솔창에 구현한 정보를 확인할 수 있다. 

1. 강남 매장은 메뉴별 가격이 존재한다.
2. 잠실 매장은 무료나눔 매장이다. (판매방식이 필요없음)

---------------------------------------

마커 인터페이스 (Marker)
	특정 클래스들을 그룹화 하기 위하여 사용한다.
	인터페이스도 타입임을 잃지 말자
	인터페이스도 부모이고 타입으로 볼 줄 알아야 한다. 

--------------------------------------------------
예외처리
	
	에러 : 심각한 오류
		컴퓨터가 정상 작동을 하지 않는것	
	예외 : 덜 심각한 오류
		
	오류 라는 표현을 사용한다.

	예외 발생 시 해당 예외 필드가 메모리에 할당되고, (이게중요!!)
	할당된 필드의 주소값이 예외가 발생된 곳으로 날아온다.
	이를 잡아주는 문법이 try catch문이다. 

try {
	오류가 날 수 있는 문장
}catch(예외이름 객체명) {
	객체명.필드명;
	
	오류 발생 시 실행할 문장
		
}catch(예외이름 객체명) {
	
}catch(예외이름 객체명) {
	
}catch(예외이름 객체명) {
	
}

-----------------------------
throws (예외 던지기)
	메소드명 () throws Exception명 {
		메소드 안에서는 위에 throws한 Exception이
		발생하지 않는다. 
		하나의 메소드 안에서 여러개의 동일한 예외가 생길때
		한번에 던지는 것이다. 
	}
-----------------------------
외부 장치 (드라이버)를 직접 연결했을 때
사용 후 반드시 장치를 닫아주어야 한다. 

1. 이 때 finally 문법을 사용한다. 
finally {
	외부 장치 닫기 (파일입출력때 더)
}

2. 이 때 try statement 문법을 사용한다. (나중에 배울것)
try (연결 객체) {

}catch () {

}

-------------------------------------------------
API(배포, 임포트) (Application Programming Interface)
	API는 라이브러리의 집합체이다.

	응용프로그램 프로그래밍 인터페이스
	프로그램을 제작할 때, 선배 개발자가 이미 구현한 소스코드를
	그대로 사용할 수 있도록 제공받는 틀이다. 

내부 API (기본제공)
	-> JDK를 깔면 생기는것
	java.lang
		자바 프로그래밍을 위한 가장 기본적인 패키지와 클래스를 포함
	java.util
		데이터를 효율적으로 저장하기 위한 패키지와 클래스를 포함
		ex) 컬렉션프레임워크
	java.io
		키보드, 모니터, 프린터, 파일 등을 제어할 수 있는
		패키지와 클래스를 포함
	java.net
		통신을 위한 패키지와 클래스를 포함
			
외부 API 
	구글맵, 카카오맵, SMS전송, 결제, 인증, 보안, ....

-------------------------------------------------------
어노테이션 주석
	/**
		@author 개발자
		@param 메소드의 매개변수
		@return 메소드의 리턴값
		@see 참고할 만한 링크 저장
		@since 릴리즈 기록(JDK기준) JDK 8
		@throws 메소드에서 발생할 수 있는 예외
		@version 클래스 버전 1.0.0
	*/
		

어노테이션 주석을 코드에 작성을 해도 자동으로 문서화 되지 않는다.
따라서 javadoc.exe프로그램을 통해 배포해야한다.

배포할 패키지 혹은 클래스 우클릭 > Export > java > javadoc >
경로(jdk.1.8xxx > bin > javadoc.exe) 설정 > finish

프로젝트 폴더 > doc > index.thml로 확인할 수 있다. 

[소스코드 배포]
	배포할 패키지 우클릭 > export > java > jar > 
	저장될 경로 설정 > finish

[API import]
	프로젝트 우클릭 > Build Path > Add External Jars
	> .jar파일 추가 > apply


--------------------------------------------------

컨스턴트풀은 램의 텍스트 영역의 상수가 잇는 곳에 있다. 
(Ram의 가장 밑에 있는 text영역)

Object 클래스 (최상위 클래스)
	최상위 클래스다.

	1. equals() : 주소 비교 (==)
		1 == 1 -> 주소비교다!

	constant pool : 상수가 넘쳐나는 곳...이다 
	상수들이 선언되어 있는 곳 

		String 클래스에서는 값 비교로 재정의 하였다. 
		
	2. hashCode()
		메모리에 할당된 필드의 주소값을 리턴한다. 
	
	3. toString()
		객체명을 출력할 때 항상 toString()이 생략된다.
		디폴트로 출력되는 문자열 값을 변경하고 싶을 때에는
		해당 클래스의 필드에서 재정의하여 사용한다. 
		클래스의 필드들을 간단하게 확인해보고자 할 때에
		많이 사용된다. 



equals와 hashcode를 재정의를 해야하는게 중요하다.
왜 재정의해야하고, 어떻게 써야하는가? 

equals를 재정의할때 hashCode도 반드시재정의 해야한다. 


------------------------------------------------------
Wrapper Class (감싸주는 클래스)
	클래스타입과 원시타입(일반타입)

	클래스 타입 = new 클래스 타입(일반타입); //박싱(boxing)
	일반타입 = 클래스타입 객체.000Value(); //언박싱(unboxing)
	
	JDK1.5버전 이상부터는 오토를 지원한다. 

	클래스 타입 = 일반 타입;	//오토 박싱(auto boxing)
	일반타입 = 클래스 타입;	//오토 언박싱 (auto unboxing)

그래서 이걸 왜써?
	보통 박싱 하여 많이 쓴다. 
	클래스 내에 유용한 메소드들이 많다.
	일반 타입에서 메소드를 사용하고 싶을 때
	클래스로 변환하여 사용하는 것이다. 

Wrapper클래스를 사용하는 이유
	일반 타입을 박싱하면 다양한 메소들을 제공받을 수 있다. 
	부모의 필드도 사용이 가능하다.
	up casting이 가능하다.
	=> 클래스에서 사용하는 것을 모두 사용할 수 있다. 

===============================================
제네릭 (이름이 없는)
	<제네릭명>
	여러가지 데이터들을 받을 때 사용하는 것
	외부에서 전달받을 타입이 어떤 타입일 지 알 수 없을 때
	사용하는 쪽에서 지정하여 사용하도록 하는 기법

E - element
K - key
N - number
T - type
V - value

1. Generic class
	클래스 내부에서 사용될 자료형을 지정한다.
	
2. Generic method
	메소드 내부에서 사용될 자료형을 지정한다. 

3. Generic interface
	인터페이스 내부에서 사용될 자료형을 지정한 후, 
	지정받은 클래스에서 제네릭을 정해준다. 

================================================

총정리>

	































